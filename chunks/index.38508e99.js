import{y as n,m as e}from"../index.61bcd498.js";import"./time.daaab1ba.js";import{P as t}from"./index.b27805ea.js";const a=["(function() {\nconst CELL_SIZE = 10;\nconst GRID_WIDTH = 48;\nconst GRID_HEIGHT = 48;\nconst TEMPO = 20;\nconst BACKGROUND = '#020c21';\nconst FOREGROUND = '#FFFF96';\nconst MAX_LAST_STEPS = 10;\nconst OFFSET = CELL_SIZE;\n\nconst canvas = document.getElementById('demo-canvas');\nconst btnReset = document.getElementById('demo-reset');\nconst btnSolve = document.getElementById('demo-solve');\nconst btnAnimate = document.getElementById('demo-animate');\nconst ctx = canvas.getContext('2d');\n\nlet walls;\nlet path = [];\n\nwalls = generateMaze();\n\nbtnReset.addEventListener('click', () => {\n    clear();\n    walls = generateMaze();\n});\n\nbtnSolve.addEventListener('click', () => {\n    run();\n})\n\nbtnAnimate.addEventListener('click', () => {\n    run(true)\n})\n\n// Generate a maze\nfunction generateMaze() {\n    path = [];\n    const set = new Set();\n    for (let y = 0; y <= GRID_HEIGHT; y++) {\n        for (let x = 0; x <= GRID_WIDTH; x++) {\n            // drawPoint(x, y);\n            if (x < GRID_WIDTH && !lucky()) {\n                drawLine(x, y, x + 1, y);\n                set.add(buildKey(x, y, x + 1, y));\n            }\n            if (y < GRID_HEIGHT && !lucky(true)) {\n                drawLine(x, y, x, y + 1);\n                set.add(buildKey(x, y, x, y + 1));\n            }\n        }\n    }\n    return set;\n}\n\nasync function solve(animate) {\n    clearAllNodes();\n    const visited = new Map();\n    let lastStep = 1;\n    // solve the maze - BFS\n    const queue = [];\n    // 1. pretend there is a root node that is just one row above the first row,\n    // all nodes on the first row that doesn't have the top wall should be added to\n    // the queue.\n    for (let x = 0; x < GRID_WIDTH; x++) {\n        if (!hasWall(x, 0, x + 1, 0)) {\n            const node = {\n                x,\n                y: 0,\n                step: 1,\n                parent: undefined,\n                parentEdge: buildKey(x, 0, x + 1, 0)\n            };\n            queue.push(node);\n        }\n    }\n    // 2. For each node in the queue,\n    // to determine whether a node has any children, check the walls set to see if\n    // three other sides have walls, for each side that doesn't have a wall, create\n    // a new node for the adjacent cell and add it to the queue.\n    while (queue.length > 0) {\n        const node = queue.shift();\n        if (animate) {\n            // when it gets to the next depth, redraw all nodes based on classification\n            if (lastStep < node.step) {\n                lastStep = await drawNodes(visited);\n            }\n        }\n        const {x, y, step, parentEdge} = node;\n        // reach the last row and if bottom is open\n        if (y === GRID_HEIGHT - 1 && !hasWall(x, y + 1, x + 1, y + 1)) {\n            clearNodes(visited);\n            return node;\n        }\n        //top\n        if (!hasWall(x, y, x + 1, y)\n            && y > 0\n            && buildKey(x, y, x + 1, y) !== parentEdge) {\n            const child = {\n                x,\n                y: y - 1,\n                step: step + 1,\n                parent: node,\n                parentEdge: buildKey(x, y, x + 1, y)\n            };\n            createNodeIfNotVisited(child);\n        }\n        //right\n        if (!hasWall(x + 1, y, x + 1, y + 1)\n            && x + 1 < GRID_WIDTH\n            && buildKey(x + 1, y, x + 1, y + 1) !== parentEdge) {\n            const child = {\n                x: x + 1,\n                y: y,\n                step: step + 1,\n                parent: node,\n                parentEdge: buildKey(x + 1, y, x + 1, y + 1)\n            };\n            createNodeIfNotVisited(child);\n        }\n        //bottom\n        if (!hasWall(x, y + 1, x + 1, y + 1)\n            && y + 1 < GRID_HEIGHT\n            && buildKey(x, y + 1, x + 1, y + 1) !== parentEdge) {\n            const child = {\n                x: x,\n                y: y + 1,\n                step: step + 1,\n                parent: node,\n                parentEdge: buildKey(x, y + 1, x + 1, y + 1)\n            };\n            createNodeIfNotVisited(child);\n        }\n        //left\n        if (!hasWall(x, y, x, y + 1)\n            && x > 0\n            && buildKey(x, y, x, y + 1) !== parentEdge) {\n            const child = {\n                x: x - 1,\n                y: y,\n                step: step + 1,\n                parent: node,\n                parentEdge: buildKey(x, y, x, y + 1)\n            };\n            createNodeIfNotVisited(child);\n        }\n    }\n\n    clearNodes(visited);\n\n    function createNodeIfNotVisited(node) {\n        const key = \"[\" + node.x + \", \" + node.y + \"]\";\n        if (!visited.has(key)) {\n            visited.set(key, node);\n            queue.push(node);\n        }\n    }\n\n// 3. this algo should stop whenever the first node that has reached the bottom\n// row, or when the queue is empty.\n// when bottom is reached, back track the path of the current node.\n// when queue is empty, restart the program.\n}\n\nasync function run(animate) {\n    clearPath(path);\n    let winningNode = await solve(animate);\n    if (winningNode) {\n        path = [];\n        while (winningNode) {\n            path.push([winningNode.x, winningNode.y]);\n            winningNode = winningNode.parent;\n        }\n        drawCenterLine(path)\n    } else {\n        warn();\n    }\n}\n\nfunction drawLine(x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(OFFSET + x1 * CELL_SIZE, OFFSET + y1 * CELL_SIZE);\n    ctx.lineTo(OFFSET + x2 * CELL_SIZE, OFFSET + y2 * CELL_SIZE);\n    ctx.strokeStyle = 'white';\n    ctx.stroke();\n}\n\nfunction drawCenterLine(path, clear = false) {\n    ctx.beginPath();\n    for (let i = 0; i < path.length; i++) {\n        const point = [OFFSET + (path[i][0] + 1 / 2) * CELL_SIZE, OFFSET + (path[i][1] + 1 / 2) * CELL_SIZE];\n        if (i === 0) {\n            ctx.moveTo(...point);\n        } else {\n            ctx.lineTo(...point);\n        }\n    }\n    ctx.lineWidth = 4;\n    ctx.strokeStyle = clear ? BACKGROUND : FOREGROUND;\n    ctx.stroke();\n    ctx.lineWidth = 1;\n}\n\n/**\n *\n * @param nodes\n * @return {Promise<*>} the current max step\n */\nasync function drawNodes(nodes) {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            const maxStep = [...nodes.values()]\n                .map(node => node.step)\n                .reduce((prev, curr) => curr > prev ? curr : prev, 0);\n            // do the drawing here\n            nodes.forEach(node => {\n                drawNodeByStep(node, maxStep);\n            })\n            resolve(maxStep);\n        }, TEMPO);\n    });\n}\n\nfunction drawNodeByStep(node, maxStep) {\n    ctx.beginPath()\n    ctx.rect(OFFSET + node.x * CELL_SIZE + 2, OFFSET + node.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);\n    // clear\n    ctx.fillStyle = BACKGROUND;\n    ctx.fill();\n    // draw new - only color the last 5 steps.\n    ctx.fillStyle = maxStep - node.step < MAX_LAST_STEPS ? \"rgba(255, 255, 150, \" + (1 - (maxStep - node.step) / MAX_LAST_STEPS) + \")\" : BACKGROUND;\n    ctx.fill();\n    ctx.fillStyle = 'white';\n}\n\nfunction clearNodes(nodes) {\n    nodes.forEach(clearNode);\n}\n\nfunction clearNode(node) {\n    ctx.beginPath()\n    ctx.rect(OFFSET + node.x * CELL_SIZE + 2, OFFSET + node.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);\n    // clear\n    ctx.fillStyle = BACKGROUND;\n    ctx.fill();\n    ctx.fillStyle = 'white';\n}\n\n// repaint all nodes but leave maze alone\nfunction clearAllNodes() {\n    for (let y = 0; y < GRID_HEIGHT - 1; y++) {\n        for (let x = 0; x < GRID_WIDTH - 1; x++) {\n            clearNode({x, y});\n        }\n    }\n}\n\nfunction clearPath(path) {\n    drawCenterLine(path, true);\n}\n\nfunction buildKey(x1, y1, x2, y2) {\n    return \"[\" + x1 + \", \" + y1 + \", \" + x2 + \", \" + y2 + \"]\";\n}\n\n/**\n * Predicate function that is determined by probability.\n * @param very {boolean}\n *  indicates a higher probability when true\n * @return {boolean}\n */\nfunction lucky(very = false) {\n    return Math.floor(Math.random() * (very ? 8 : 6)) + 1 <= 4;\n}\n\nfunction hasWall(x1, y1, x2, y2) {\n    return walls.has(buildKey(x1, y1, x2, y2));\n}\n\nfunction clear() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nfunction warn() {\n    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';\n    ctx.rect(0, 0, canvas.width, canvas.height);\n    ctx.fill();\n    ctx.fillStyle = 'white';\n}\n})()"];export default function(){return n(()=>{a.forEach(n=>new Function(n)())},[]),e`<${t} ...${{title:"Implement the Lightning Algorithm",date:"2021-09-15 09:27:00"}} summary=${"<p>I was entertaining myself with the excellent video interviews from the NumberPhile project, a lightning algorithm interview from the creator of the visualization of the algorithm clearly explained the techniques used behind the scene. The explanation was so clear and the visualization was so satisfying that I felt impetuous to implement it. A few hours later, the moment of thought became realized. Here sharing a few steps that I learned from the interview and while implementing it. </p>\n"}>
      <article dangerouslySetInnerHTML=${{__html:'<h2>\n  <a id="the-demo" class="anchor" aria-hidden="true" href="#the-demo">\n    <svg class="icon" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg>\n  </a>The Demo</h2><style>\n    #demo-canvas {\n        background: #020c21;\n    }\n</style>\n\n<p><canvas id="demo-canvas" width="500px" height="500px"></canvas></p>\n<div>\n<button id="demo-reset">New Maze</button>\n<button id="demo-solve">Solve</button>\n<button id="demo-animate">Animate</button>\n</div>\n\n<script>\n(function() {\nconst CELL_SIZE = 10;\nconst GRID_WIDTH = 48;\nconst GRID_HEIGHT = 48;\nconst TEMPO = 20;\nconst BACKGROUND = \'#020c21\';\nconst FOREGROUND = \'#FFFF96\';\nconst MAX_LAST_STEPS = 10;\nconst OFFSET = CELL_SIZE;\n\nconst canvas = document.getElementById(\'demo-canvas\');\nconst btnReset = document.getElementById(\'demo-reset\');\nconst btnSolve = document.getElementById(\'demo-solve\');\nconst btnAnimate = document.getElementById(\'demo-animate\');\nconst ctx = canvas.getContext(\'2d\');\n\nlet walls;\nlet path = [];\n\nwalls = generateMaze();\n\nbtnReset.addEventListener(\'click\', () => {\n    clear();\n    walls = generateMaze();\n});\n\nbtnSolve.addEventListener(\'click\', () => {\n    run();\n})\n\nbtnAnimate.addEventListener(\'click\', () => {\n    run(true)\n})\n\n// Generate a maze\nfunction generateMaze() {\n    path = [];\n    const set = new Set();\n    for (let y = 0; y <= GRID_HEIGHT; y++) {\n        for (let x = 0; x <= GRID_WIDTH; x++) {\n            // drawPoint(x, y);\n            if (x < GRID_WIDTH && !lucky()) {\n                drawLine(x, y, x + 1, y);\n                set.add(buildKey(x, y, x + 1, y));\n            }\n            if (y < GRID_HEIGHT && !lucky(true)) {\n                drawLine(x, y, x, y + 1);\n                set.add(buildKey(x, y, x, y + 1));\n            }\n        }\n    }\n    return set;\n}\n\nasync function solve(animate) {\n    clearAllNodes();\n    const visited = new Map();\n    let lastStep = 1;\n    // solve the maze - BFS\n    const queue = [];\n    // 1. pretend there is a root node that is just one row above the first row,\n    // all nodes on the first row that doesn\'t have the top wall should be added to\n    // the queue.\n    for (let x = 0; x < GRID_WIDTH; x++) {\n        if (!hasWall(x, 0, x + 1, 0)) {\n            const node = {\n                x,\n                y: 0,\n                step: 1,\n                parent: undefined,\n                parentEdge: buildKey(x, 0, x + 1, 0)\n            };\n            queue.push(node);\n        }\n    }\n    // 2. For each node in the queue,\n    // to determine whether a node has any children, check the walls set to see if\n    // three other sides have walls, for each side that doesn\'t have a wall, create\n    // a new node for the adjacent cell and add it to the queue.\n    while (queue.length > 0) {\n        const node = queue.shift();\n        if (animate) {\n            // when it gets to the next depth, redraw all nodes based on classification\n            if (lastStep < node.step) {\n                lastStep = await drawNodes(visited);\n            }\n        }\n        const {x, y, step, parentEdge} = node;\n        // reach the last row and if bottom is open\n        if (y === GRID_HEIGHT - 1 && !hasWall(x, y + 1, x + 1, y + 1)) {\n            clearNodes(visited);\n            return node;\n        }\n        //top\n        if (!hasWall(x, y, x + 1, y)\n            && y > 0\n            && buildKey(x, y, x + 1, y) !== parentEdge) {\n            const child = {\n                x,\n                y: y - 1,\n                step: step + 1,\n                parent: node,\n                parentEdge: buildKey(x, y, x + 1, y)\n            };\n            createNodeIfNotVisited(child);\n        }\n        //right\n        if (!hasWall(x + 1, y, x + 1, y + 1)\n            && x + 1 < GRID_WIDTH\n            && buildKey(x + 1, y, x + 1, y + 1) !== parentEdge) {\n            const child = {\n                x: x + 1,\n                y: y,\n                step: step + 1,\n                parent: node,\n                parentEdge: buildKey(x + 1, y, x + 1, y + 1)\n            };\n            createNodeIfNotVisited(child);\n        }\n        //bottom\n        if (!hasWall(x, y + 1, x + 1, y + 1)\n            && y + 1 < GRID_HEIGHT\n            && buildKey(x, y + 1, x + 1, y + 1) !== parentEdge) {\n            const child = {\n                x: x,\n                y: y + 1,\n                step: step + 1,\n                parent: node,\n                parentEdge: buildKey(x, y + 1, x + 1, y + 1)\n            };\n            createNodeIfNotVisited(child);\n        }\n        //left\n        if (!hasWall(x, y, x, y + 1)\n            && x > 0\n            && buildKey(x, y, x, y + 1) !== parentEdge) {\n            const child = {\n                x: x - 1,\n                y: y,\n                step: step + 1,\n                parent: node,\n                parentEdge: buildKey(x, y, x, y + 1)\n            };\n            createNodeIfNotVisited(child);\n        }\n    }\n\n    clearNodes(visited);\n\n    function createNodeIfNotVisited(node) {\n        const key = "[" + node.x + ", " + node.y + "]";\n        if (!visited.has(key)) {\n            visited.set(key, node);\n            queue.push(node);\n        }\n    }\n\n// 3. this algo should stop whenever the first node that has reached the bottom\n// row, or when the queue is empty.\n// when bottom is reached, back track the path of the current node.\n// when queue is empty, restart the program.\n}\n\nasync function run(animate) {\n    clearPath(path);\n    let winningNode = await solve(animate);\n    if (winningNode) {\n        path = [];\n        while (winningNode) {\n            path.push([winningNode.x, winningNode.y]);\n            winningNode = winningNode.parent;\n        }\n        drawCenterLine(path)\n    } else {\n        warn();\n    }\n}\n\nfunction drawLine(x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(OFFSET + x1 * CELL_SIZE, OFFSET + y1 * CELL_SIZE);\n    ctx.lineTo(OFFSET + x2 * CELL_SIZE, OFFSET + y2 * CELL_SIZE);\n    ctx.strokeStyle = \'white\';\n    ctx.stroke();\n}\n\nfunction drawCenterLine(path, clear = false) {\n    ctx.beginPath();\n    for (let i = 0; i < path.length; i++) {\n        const point = [OFFSET + (path[i][0] + 1 / 2) * CELL_SIZE, OFFSET + (path[i][1] + 1 / 2) * CELL_SIZE];\n        if (i === 0) {\n            ctx.moveTo(...point);\n        } else {\n            ctx.lineTo(...point);\n        }\n    }\n    ctx.lineWidth = 4;\n    ctx.strokeStyle = clear ? BACKGROUND : FOREGROUND;\n    ctx.stroke();\n    ctx.lineWidth = 1;\n}\n\n/**\n *\n * @param nodes\n * @return {Promise<*>} the current max step\n */\nasync function drawNodes(nodes) {\n    return new Promise(resolve => {\n        setTimeout(() => {\n            const maxStep = [...nodes.values()]\n                .map(node => node.step)\n                .reduce((prev, curr) => curr > prev ? curr : prev, 0);\n            // do the drawing here\n            nodes.forEach(node => {\n                drawNodeByStep(node, maxStep);\n            })\n            resolve(maxStep);\n        }, TEMPO);\n    });\n}\n\nfunction drawNodeByStep(node, maxStep) {\n    ctx.beginPath()\n    ctx.rect(OFFSET + node.x * CELL_SIZE + 2, OFFSET + node.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);\n    // clear\n    ctx.fillStyle = BACKGROUND;\n    ctx.fill();\n    // draw new - only color the last 5 steps.\n    ctx.fillStyle = maxStep - node.step < MAX_LAST_STEPS ? "rgba(255, 255, 150, " + (1 - (maxStep - node.step) / MAX_LAST_STEPS) + ")" : BACKGROUND;\n    ctx.fill();\n    ctx.fillStyle = \'white\';\n}\n\nfunction clearNodes(nodes) {\n    nodes.forEach(clearNode);\n}\n\nfunction clearNode(node) {\n    ctx.beginPath()\n    ctx.rect(OFFSET + node.x * CELL_SIZE + 2, OFFSET + node.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);\n    // clear\n    ctx.fillStyle = BACKGROUND;\n    ctx.fill();\n    ctx.fillStyle = \'white\';\n}\n\n// repaint all nodes but leave maze alone\nfunction clearAllNodes() {\n    for (let y = 0; y < GRID_HEIGHT - 1; y++) {\n        for (let x = 0; x < GRID_WIDTH - 1; x++) {\n            clearNode({x, y});\n        }\n    }\n}\n\nfunction clearPath(path) {\n    drawCenterLine(path, true);\n}\n\nfunction buildKey(x1, y1, x2, y2) {\n    return "[" + x1 + ", " + y1 + ", " + x2 + ", " + y2 + "]";\n}\n\n/**\n * Predicate function that is determined by probability.\n * @param very {boolean}\n *  indicates a higher probability when true\n * @return {boolean}\n */\nfunction lucky(very = false) {\n    return Math.floor(Math.random() * (very ? 8 : 6)) + 1 <= 4;\n}\n\nfunction hasWall(x1, y1, x2, y2) {\n    return walls.has(buildKey(x1, y1, x2, y2));\n}\n\nfunction clear() {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nfunction warn() {\n    ctx.fillStyle = \'rgba(255, 0, 0, 0.2)\';\n    ctx.rect(0, 0, canvas.width, canvas.height);\n    ctx.fill();\n    ctx.fillStyle = \'white\';\n}\n})()\n<\/script>\n\n<h2>\n  <a id="generate-a-maze" class="anchor" aria-hidden="true" href="#generate-a-maze">\n    <svg class="icon" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg>\n  </a>Generate a maze</h2><p>We start by creating a grid that shows only points so that we could connect them based on a certain probability.</p>\n<p><img alt="Grid base" title="null" src="data:image/png;base64,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" /></p>\n'}}/>
    </${t}>`}
function $w_s$(e,t){document.querySelector('link[rel=stylesheet][href="'+e+'"]')||((t=document.createElement("link")).rel="stylesheet",t.href=e,document.head.appendChild(t))}
$w_s$("/assets/style.module.184703f0.css");