import{m as e}from"../index.e45ada53.js";import"./time.daaab1ba.js";import{P as t}from"./index.1cdefbad.js";export default function(){return e`<${t} ...${{title:"Handle Non-encoded Request URL",date:"2018-10-14T17:00:00.000Z"}}>
      <article dangerouslySetInnerHTML=${{__html:'<h2>\n  <a id="normally-we-need-to-encode-the-request-url-from-the-client-before-sending-a-request-to-the-server-but-there-may-be-just-one-time-that-you-really-can-39-t-enforce-the-client-to-encode-their-request-url-and-sometimes-it-contains-special-characters-that-will-make-the-server-mark-them-as-illegal-characters-in-the-request-this-article-shows-an-example-of-how-to-use-a-filter-to-preprocess-the-request-on-the-server-side-" class="anchor" aria-hidden="true" href="#normally-we-need-to-encode-the-request-url-from-the-client-before-sending-a-request-to-the-server-but-there-may-be-just-one-time-that-you-really-can-39-t-enforce-the-client-to-encode-their-request-url-and-sometimes-it-contains-special-characters-that-will-make-the-server-mark-them-as-illegal-characters-in-the-request-this-article-shows-an-example-of-how-to-use-a-filter-to-preprocess-the-request-on-the-server-side-">\n    <svg class="icon" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg>\n  </a>Normally we need to encode the request URL from the client before sending a request to the server, but there may be just one time that you really can&#39;t enforce the client to encode their request URL and sometimes it contains special characters that will make the server mark them as illegal characters in the request. This article shows an example of how to use a filter to preprocess the request on the server side.</h2><h2>\n  <a id="bad-url" class="anchor" aria-hidden="true" href="#bad-url">\n    <svg class="icon" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg>\n  </a>Bad URL</h2><p>If you copy and paste the following URL that takes an query parameter as <code>input</code> and the value as <code>{&quot;inputInfo&quot;:{&quot;inputText&quot;:&quot;5.00%&quot;}} </code> - a JSON literal that contains a special character <code>%</code>. Your server will most likely complain and throw an exception on this illegal character.</p>\n<div class="codeblock">\n  <pre> http://localhost:8090/extract?input={&quot;inputInfo&quot;:{&quot;inputText&quot;:&quot;5.00%&quot;}} </pre>\n</div><h2>\n  <a id="what-could-be-done-to-solve-this-problem-from-the-server-side-" class="anchor" aria-hidden="true" href="#what-could-be-done-to-solve-this-problem-from-the-server-side-">\n    <svg class="icon" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg>\n  </a>What could be done to solve this problem from the server side?</h2><ul>\n<li>use Spring preprocessor bean to preprocess the request</li>\n<li>use Spring AspectJ to preprocess the request</li>\n<li>use Spring servlet filter to preprocess the request</li>\n</ul>\n<p>With any of the above cross-cutting strategies, you could encode the request URL and pass back to the endpoint.</p>\n<h2>\n  <a id="example" class="anchor" aria-hidden="true" href="#example">\n    <svg class="icon" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg>\n  </a>Example</h2><p>Below is one implementation using Filter. You could possibly do some caching there if you need better performance.</p>\n<p>The key points are:</p>\n<ol>\n<li><code>HttpServletRequest</code> is immutable, we must use the wrapper type <code>HttpServletRequestWrapper</code> to create a <code>HttpServletRequest</code> object and pass down to the filter chain.</li>\n<li>The special characters need to be manually escaped in the new <code>HttpServletRequest</code> object.</li>\n<li>Apply proper caching strategies to reduce the heavy computations (this is not implemented here).</li>\n</ol>\n<div class="codeblock">\n  <pre>@Component\npublic class SomeFilter implements Filter {\n    private static final Logger LOGGER = LoggerFactory.getLogger(SomeFilter.class);\n\n    @Override\n    public void init(final FilterConfig filterConfig) throws ServletException {\n\n    }\n\n    @Override\n    public void doFilter(final ServletRequest servletRequest, final ServletResponse servletResponse, final FilterChain filterChain) throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        HttpServletRequest modifiedRequest = new SomeHttpServletRequest(request);\n        filterChain.doFilter(modifiedRequest, servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n\n    }\n\n    class SomeHttpServletRequest extends HttpServletRequestWrapper {\n        HttpServletRequest request;\n\n        SomeHttpServletRequest(final HttpServletRequest request) {\n            super(request);\n            this.request = request;\n        }\n\n        @Override\n        public String getQueryString() {\n            String queryString = request.getQueryString();\n            LOGGER.info(&quot;Original query string: &quot; + queryString);\n\n            try {\n                // You need to escape all your non encoded special characters here\n                String specialChar = URLEncoder.encode(&quot;%&quot;, &quot;UTF-8&quot;);\n                queryString = queryString.replaceAll(&quot;\\%\\%&quot;, specialChar + &quot;%&quot;);\n\n                String decoded = URLDecoder.decode(queryString, &quot;UTF-8&quot;);\n                LOGGER.info(&quot;Modified query string: &quot;  + decoded);\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n\n            return queryString;\n        }\n\n        @Override\n        public String getParameter(final String name) {\n            String[] params = getParameterMap().get(name);\n            return params.length &gt; 0 ? params[0] : null;\n        }\n\n        @Override\n        public Map&lt;String, String[]&gt; getParameterMap() {\n            String queryString = getQueryString();\n            return getParamsFromQueryString(queryString);\n        }\n\n        @Override\n        public Enumeration&lt;String&gt; getParameterNames() {\n            return Collections.enumeration(getParameterMap().keySet());\n        }\n\n        @Override\n        public String[] getParameterValues(final String name) {\n            return getParameterMap().get(name);\n        }\n\n        private Map&lt;String, String[]&gt; getParamsFromQueryString(final String queryString) {\n            String decoded = &quot;&quot;;\n            try {\n                decoded = URLDecoder.decode(queryString, &quot;UTF-8&quot;);\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n            String[] params = decoded.split(&quot;&amp;&quot;);\n            Map&lt;String, List&lt;String&gt;&gt; collect = Stream.of(params)\n                .map(x -&gt; x.split(&quot;=&quot;))\n                .collect(Collectors.groupingBy(\n                    x -&gt; x[0],\n                    Collectors.mapping(\n                        x -&gt; x.length &gt; 1 ? x[1] : null,\n                        Collectors.toList())));\n\n            Map&lt;String, String[]&gt; result = collect.entrySet().stream()\n                .collect(Collectors.toMap(\n                    x -&gt; x.getKey(),\n                    x -&gt; x.getValue()\n                        .stream()\n                        .toArray(String[]::new)));\n\n            return result;\n        }\n    }\n}</pre>\n</div>'}}/>
    </${t}>`}